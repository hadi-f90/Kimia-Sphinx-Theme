
پالایش ها: بخش 2
===================

علّت مشکل آخر قسمت 1 این جاست. ما نشانه رو گذاشتیم؛ ولی قبل از این که فرصتی برای حرکت داشته باشیم امتحان کردیم ببینیم نزدیکش ایستاده‌ایم یا نه. از آن جایی که روی بیپر بودیم هیچ وقت امکان رفتن تویحلقه‌ی ``while`` رو نداشتیم. شاید بتونیم برنامه رو با افزودن یک ``move()`` قبل از شروع حلقه درست کنیم؛ مثل این::

    put()
    move()
    while not object_here():
        if front_is_clear():
            move()
        else:
            turn_left()

.. topic:: امتحان کنید!

   قبل از این که ادامه بدید امتحان کنید ببینید تا مطمئن بشید برنامه کار می کنه یا نه.

دنیا پیچیده تر از اون حرفاست
---------------------------------

بیاید برنامه‌ای رو که نوشتیم رو توی یک محیط یه خورده پیچیده‌تر **همین دور و بر 2 (Around 2)** امتحان کنیم. 

.. note::

    یادتون نره این رو تو برنامه تون بگذارید::

        from library import turn_right

وقتی برنامه تون رو امتحان می‌کنید، می‌بینید که نتیجه دقیقاً اون چیزی که می‌خواستیم، نیست: ریبرگ میان بر می‌زنه و همه‌ی محیط رو دور نمی‌زنه. مشکل اینه که ما فرض کردیم ریبرگ فقط باید جلو بره یا به چپ به پیچه تا محیطش رو دور بزنه، هیچ وقت هرگز حساب این جور موقعیت‌هایی رو نکردیم که تو اون از ریبرگ بخواهیم به راست به پیچه. کاری که ریبرگ باید به کنه اینه که اول سمت راستش رو چک کنه ببینه آیا هنوز دیواری هست؛ اگر نبود، کاری کنیم که به راست به پیچه. این برنامه‌ی تغییر یافته‌ای هست که دقیقاً برای *انجام* همین کار هست::

    put()
    move()
    while not object_here():
        if right_is_clear():
            turn_right()
        elif front_is_clear():
            move()
        else:
            turn_left()

.. topic:: نوبت شما!

    کار می کنه؟ به دقّت بخونیدش تا خودتون تصمیم بگیرید. بعد اجراش کنید تا ببینید نظر شما رو تأیید می کنه؟ اگه نشد، هر تغییری که فکر می‌کنید مناسب هست انجام بدید.
